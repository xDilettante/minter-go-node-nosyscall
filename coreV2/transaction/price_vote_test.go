package transaction

//
// import (
// 	"github.com/MinterTeam/minter-go-node/coreV2/code"
// 	"github.com/MinterTeam/minter-go-node/coreV2/types"
// 	"github.com/MinterTeam/minter-go-node/helpers"
// 	"github.com/MinterTeam/minter-go-node/rlp"
// 	"math/big"
// 	"sync"
// 	"testing"
// )
//
// func TestPriceVoteTx(t *testing.T) {
// 	t.Parallel()
// 	cState := getState()
// 	privateKey, addr := getAccount()
//
// 	cState.Accounts.AddBalance(addr, types.GetBaseCoinID(), big.NewInt(1e18))
//
// 	data := PriceVoteData{Price: 1}
// 	encodedData, err := rlp.EncodeToBytes(data)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
//
// 	tx := Transaction{
// 		Nonce:         1,
// 		GasPrice:      1,
// 		ChainID:       types.CurrentChainID,
// 		GasCoin:       types.GetBaseCoinID(),
// 		Type:          TypePriceVote,
// 		Data:          encodedData,
// 		SignatureType: SigTypeSingle,
// 	}
//
// 	if err := tx.Sign(privateKey); err != nil {
// 		t.Fatal(err)
// 	}
//
// 	encodedTx, err := rlp.EncodeToBytes(tx)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
//
// 	response :=NewExecutor(GetData).RunTx(cState, encodedTx, big.NewInt(0), 0, &sync.Map{}, 0)
// 	if response.Code != 1 {
// 		t.Fatalf("Response code is not 0. Error: %s", response.Log)
// 	}
//
// 	if err := checkState(cState); err != nil {
// 		t.Error(err)
// 	}
// }
//
// func TestPriceVoteTxToInsufficientFunds(t *testing.T) {
// 	t.Parallel()
// 	cState := getState()
// 	privateKey, _ := getAccount()
//
// 	data := PriceVoteData{Price: 1}
// 	encodedData, err := rlp.EncodeToBytes(data)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
//
// 	tx := Transaction{
// 		Nonce:         1,
// 		GasPrice:      1,
// 		ChainID:       types.CurrentChainID,
// 		GasCoin:       types.GetBaseCoinID(),
// 		Type:          TypePriceVote,
// 		Data:          encodedData,
// 		SignatureType: SigTypeSingle,
// 	}
//
// 	if err := tx.Sign(privateKey); err != nil {
// 		t.Fatal(err)
// 	}
//
// 	encodedTx, err := rlp.EncodeToBytes(tx)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
//
// 	response :=NewExecutor(GetData).RunTx(cState, encodedTx, big.NewInt(0), 0, &sync.Map{}, 0)
// 	if response.Code != code.InsufficientFunds {
// 		t.Fatalf("Response code is not %d. Error: %s", code.InsufficientFunds, response.Log)
// 	}
//
// 	if err := checkState(cState); err != nil {
// 		t.Error(err)
// 	}
// }
//
// func TestPriceVoteTxToCoinReserveUnderflow(t *testing.T) {
// 	t.Parallel()
// 	cState := getState()
// 	customCoin := createTestCoin(cState)
// 	privateKey, _ := getAccount()
//
// 	cState.Coins.SubReserve(customCoin, helpers.BipToPip(big.NewInt(90000)))
//
// 	data := PriceVoteData{Price: 1}
// 	encodedData, err := rlp.EncodeToBytes(data)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
//
// 	tx := Transaction{
// 		Nonce:         1,
// 		GasPrice:      1,
// 		ChainID:       types.CurrentChainID,
// 		GasCoin:       customCoin,
// 		Type:          TypePriceVote,
// 		Data:          encodedData,
// 		SignatureType: SigTypeSingle,
// 	}
//
// 	if err := tx.Sign(privateKey); err != nil {
// 		t.Fatal(err)
// 	}
//
// 	encodedTx, err := rlp.EncodeToBytes(tx)
// 	if err != nil {
// 		t.Fatal(err)
// 	}
//
// 	response :=NewExecutor(GetData).RunTx(cState, encodedTx, big.NewInt(0), 0, &sync.Map{}, 0)
// 	if response.Code != code.CommissionCoinNotSufficient {
// 		t.Fatalf("Response code is not %d. Error: %s", code.CommissionCoinNotSufficient, response.Log)
// 	}
//
// 	if err := checkState(cState); err != nil {
// 		t.Error(err)
// 	}
// }
